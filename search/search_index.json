{"config":{"lang":["en"],"separator":"[\\s\\-\\.]","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Automython","text":"<p>Copyright 2024 Matthew Kanter Released under the MIT license</p> <p></p>"},{"location":"#httpspypiorgprojectautomython","title":"<code>https://pypi.org/project/automython</code>","text":"<p>The Automython interpreter is a simple programming language that interprets its source code to Python as its target code to help understand and visualize automata theory.</p> <p>This project originially started out as my senior capstone project at umw i would complete to graduate with university honors. it originally started out as a proposal to create a whole new programming language, writing a compiler that translates my designed syntax into machine code to run a finite automata (either a deterministic finite automata (DFA) or non-deterministic (NFA), or if time permitted since it was only a one semester project a Turing machine) and output to the user a graph visualization of the inputted 5-tuple automata, whether an optional input word was accepted or rejected by the automata, and a table of transition functions/steps.</p> <p>It slowly evolved as I worked closely with my fantastic professor, Dr. Andrew Marshall into creating an interpreter to Python to make use of pre-existing visualization libraries (automata-lib, visual-automata) and the small scope of the operations this language would have to perform. After all, what's the point of creating a whole new programming language that only performs one basic function when you could instead create a programming language that translates to a more widely used and broader use case programming language to make use of already written higher level logic? Point proven, nobody wants to write assembly. shudders</p> <p>Thank you to Leonardo Giordani for his TDD work on a simple calculator interpreter in Python that was heavily adapted for this package.</p> <p>This package requires Python 3.8 or newer.</p>"},{"location":"#prerequisites","title":"Prerequisites","text":"<p>You must have GraphViz's packages installed on your device.</p> <pre><code>pip install 'automata-lib[visual]'\npip install pandas\npip install ipython\npip install forbiddenfruit\n</code></pre>"},{"location":"#installing","title":"Installing","text":"<p>You can install the latest version of Automython via <code>pip</code>:</p> <pre><code>pip install automython\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>Automython can be used in two ways, similar to Python. It can be used as a command line interface or by passing in it's own readable <code>.theory</code> file type to read.</p>"},{"location":"#cli","title":"CLI","text":"<p>Automython can be used similarly to how <code>python</code> can be on the command line. Simply run to bring up the interface:</p> <pre><code>automython\n</code></pre>"},{"location":"#file-syntax","title":"File Syntax","text":"<p>To use this package once installed, you need to have a file with the extension <code>.theory</code> to run it on. This <code>.theory</code> file has very simiilar syntax definitions to Python, however with some limitations as the scope is not quite that large.</p> <p>All types in the <code>.theory</code> file operate the same as Python. The \"native\" types (supported types that are converted to Python) for Automython are:</p> <ul> <li><code>Integer</code></li> <li><code>String</code></li> <li><code>Boolean</code></li> <li><code>Dictionary</code></li> <li><code>Set</code></li> <li><code>Tuple</code></li> </ul> <p>Computational theory objects that are supported are: - <code>DFA</code> (i.e. <code>DFA(states, input_symbols, transitions, initial_state, final_states, allow_partial[optional]: bool</code>) - <code>NFA</code> (i.e. <code>NFA(states, input_symbols, transitions, initial_state, final_states)</code>) The parameters within these calls can be substituted for any native types supported.</p> <p>Variables exist. Variables are defined such that <code>x = {'s1', 's2'}</code> assigns that set to the <code>x</code> variable.</p> <p>Function calls exist too. Function calls return a value, usually only a string. You can assign a variable to these function_calls. The available functions to use are:</p> <ul> <li><code>save()</code></li> <li><code>definition()</code></li> <li><code>test()</code></li> <li><code>open()</code></li> <li><code>print()</code></li> </ul> <p>Each function can be wrapped in <code>print()</code> to display the value returned from each function.</p>"},{"location":"functions/","title":"Functions","text":""},{"location":"functions/#savepathoptional-input_stringoptional-horizontaloptional","title":"<code>save(path[optional], input_string[optional], horizontal[optional])</code>","text":"<p>The <code>save()</code> function can only be used when calling it on an automata variable already assigned, i.e. <code>fa.save()</code>.</p> <p>When executed, this function will, by default, save the automata object's graph to a file named after the variable name, i.e. <code>fa.png</code>.</p> <ul> <li>If the <code>path</code> parameter is specified, which is a string, the function will save the automata object's graph to that path/file name.</li> <li>If the <code>input_string</code> parameter is specified, which is a string containing the input symbols from the automata's object, the function will save the automata object's graph with a gradient of transitions taken through the input_string as a test string. The transitions gradient in the saved file will be green if the string is accepted, or red if the string is rejected. This is, in essence, the visual representation of <code>test()</code> </li> <li>If the <code>horizontal</code> parameter is specified, which is a boolean, the function will save the automata object's graph in horizontal dimensions if <code>True</code> or vertical dimensions if <code>False</code>.</li> </ul>"},{"location":"functions/#definition","title":"<code>definition()</code>","text":"<p>The <code>definition()</code> function can only be used when calling it on an automata variable already assigned, i.e. <code>fa.definition()</code>.</p> <p>When executed, this function will return a string representation of the transition table-like structure of the automata object. You can use something like <code>print(fa.definition())</code> to print it to standard out.</p> <ul> <li>The \u2192 symbol denotes the initial state.</li> <li>The * symbol denotes an accepting state.</li> </ul>"},{"location":"functions/#testinput_string","title":"<code>test(input_string)</code>","text":"<p>The <code>test()</code> function can only be used when calling it on an automata variable already assigned, i.e. <code>fa.test(\"1010\")</code>.</p> <p>When executed, this function will return a string representation of the transition steps took through the automata. It returns this as a table-like structure, and also returns whether or not the input string is accepted or rejected by the automata. This is, in essense, the textual representation of <code>definition()</code></p> <ul> <li>The <code>input_string</code> argument must be a string.</li> <li>The \u2192 symbol denotes the initial state.</li> <li>The * symbol denotes an accepting state.</li> </ul>"},{"location":"functions/#openpathoptional","title":"<code>open(path[optional])</code>","text":"<p>When executed, this function will, by default, open a file called <code>M.png</code> in the same directory as when <code>automython</code> command that was run.</p> <ul> <li>If the function is executed in the same way as <code>save()</code>, i.e. <code>fa.open()</code>, the default file it will open will be the variable it is called on (<code>fa.png</code>).</li> <li>If the <code>path</code> parameter is specified, which is a string, the function will open the specified file in the OS native viewer. If the path is specified and the function is called on a variable, the variable it is called on is obsolete, and the path parameter takes precedence.</li> </ul>"},{"location":"functions/#printargsoptional","title":"<code>print(args[optional])</code>","text":"<p>The <code>print()</code> function is intended to be used as a standalone function, similar to how it is used in Python. If the function is called on a variable, the variable is obsolete. If the function is assigned to a variable, the variable will store <code>None</code>.</p> <ul> <li>If the <code>args</code> parameter is passed, this can be a variable, function call, expression, or \"native\" type, the string representation of whatever is passed in is printed straight through Python's <code>print()</code> function.</li> <li>If <code>args</code> is not passed, it will run the equivalent of <code>print('')</code> in Python.</li> </ul>"},{"location":"people/","title":"People","text":""},{"location":"people/#maintainers","title":"Maintainers","text":"<ul> <li>mkantrr</li> </ul>"},{"location":"types/","title":"Types","text":""},{"location":"types/#integer","title":"Integer","text":"<p>Integers in Automython act the same as <code>int</code>s in Python.</p>"},{"location":"types/#string","title":"String","text":"<p>Strings in Automython act the same as <code>str</code>s in Python. You can use both <code>'</code> or <code>\"</code> symbols to enclose them, just like Python.</p>"},{"location":"types/#boolean","title":"Boolean","text":"<p>Booleans in Automython act the same as <code>bool</code>s in Python.</p>"},{"location":"types/#dictionary","title":"Dictionary","text":"<p>Dictioniaries in Automython act the same as <code>dict</code>s in Python. The only difference in the more limited support types for what you can assign to keys to only Automython's \"native\" types, and no other Python types that are not included.</p>"},{"location":"types/#set","title":"Set","text":"<p>Sets in Automython act the same as <code>set</code>s in Python. The only difference is the more limited support types for what you can assign to keys to only Automython's \"native\" types, and no other Python types that are not included.</p>"},{"location":"types/#tuple","title":"Tuple","text":"<p>Tuples in Automython act the same as <code>tuple</code>s in Python. The only difference is the more limited support, as you cannot perform most of the Python tuple functions and slick scripting you can here. They are built for a specific purpose, and it is moreso to be integrated with the computational theory concepts below.</p>"},{"location":"types/#dfa","title":"DFA","text":"<p>Deterministic Finite Automaton:</p> <p>The DFA object in Automython must resemble this syntax: <pre><code>DFA(states, input_symbols, transitions, initial_state, final_states, allow_partial[optional]: bool)\n</code></pre> It must also be assigned to a variable; it cannot be treated as an expression, i.e.: <pre><code>dfa = DFA(states, input_symbols, transitions, initial_state, final_states, allow_partial[optional]: bool)\n</code></pre></p> <ul> <li>The <code>states</code> argument is a Set. This can be either a Set in the argument, or a variable that stores a Set.</li> <li>The <code>input_symbols</code> argument is a Set. This can be either a Set in the argument, or a variable that stores a Set.</li> <li>The <code>transitions</code> argument is a Dictionary. This can be either a Dictionary in the argument, or a variable that stores a Dictionary. The values of each key maps to an input symbol as a key to a String denoting the state.</li> <li>The <code>initial_state</code> argument is a String. This can be either a String in the argument, or a variable that stores a String.</li> <li>The <code>final_states</code> argument is a Set. This can be either a Set in the argument, or a variable that stores a Set.</li> <li>The <code>allow_partial</code> argument is optional, and is a Boolean. The default value is <code>False</code> if it is not specified, but if it is specified, it allows the DFA to be validated as a partial DFA. </li> </ul>"},{"location":"types/#nfa","title":"NFA","text":"<p>Non-deterministic Finite Automaton:</p> <p>The NFA object in Automython must resemble this syntax: <pre><code>NFA(states, input_symbols, transitions, initial_state, final_states)\n</code></pre> It must also be assigned to a variable; it cannot be treated as an expression, i.e.: <pre><code>nfa = NFA(states, input_symbols, transitions, initial_state, final_states)\n</code></pre></p> <ul> <li>The <code>states</code> argument is a Set. This can be either a Set in the argument, or a variable that stores a Set.</li> <li>The <code>input_symbols</code> argument is a Set. This can be either a Set in the argument, or a variable that stores a Set.</li> <li>The <code>transitions</code> argument is a Dictionary. This can be either a Dictionary in the argument, or a variable that stores a Dictionary. The values of each key maps to an input symbol as a key to a Set of states.</li> <li>The <code>initial_state</code> argument is a String. This can be either a String in the argument, or a variable that stores a String.</li> <li>The <code>final_states</code> argument is a Set. This can be either a Set in the argument, or a variable that stores a Set.</li> </ul>"},{"location":"types/#dtm","title":"DTM","text":"<p>Deterministic Turing Machine:</p> <p>The DFA object in Automython must resemble this syntax: <pre><code>DTM(states, input_symbols, tape_symbols, transitions, initial_state, blank_symbol, final_states)\n</code></pre> It must also be assigned to a variable; it cannot be treated as an expression, i.e.: <pre><code>dtm = DTM(states, input_symbols, tape_symbols, transitions, initial_state, blank_symbol, final_states)\n</code></pre></p> <ul> <li>The <code>states</code> argument is a Set. This can be either a Set in the argument, or a variable that stores a Set.</li> <li>The <code>input_symbols</code> argument is a Set. This can be either a Set in the argument, or a variable that stores a Set. These symbols are all Strings, and are the only symbols that can exist on the tape before the Turing machine begins its run.</li> <li>The <code>tape_symbols</code> argument is a Set. This can be either a Set in the argument, or a variable that stores a Set. These symbols are all Strings that are able to be read and written on the tape.</li> <li>The <code>transitions</code> argument is a Dictionary. This can be either a Dictionary in the argument, or a variable that stores a Dictionary. The values of each key maps to an input symbol as a key to a Tuple of strings denoting the new state, write symbol, and direction to move on the tape.</li> <li>The <code>initial_state</code> argument is a String. This can be either a String in the argument, or a variable that stores a String.</li> <li>The <code>blank_symbol</code> argument is a String. This can be either a String in the argument, or a variable that stores a String. This is the symbol on the tape that fills theoretical space on the tape where the input is not.</li> <li>The <code>final_states</code> argument is a Set. This can be either a Set in the argument, or a variable that stores a Set.</li> </ul>"},{"location":"examples/fa-examples/","title":"FA Examples","text":"<p>This page hosts some examples of <code>.theory</code> syntax files that you can copy and paste and try yourself.</p>"},{"location":"examples/fa-examples/#testing-types","title":"Testing types","text":"<p>The following code snippet creates a few variables and prints them, as well as printing non-assigned values. <pre><code>integer = 123\nprint(integer)\nprint()\nprint(123)\nprint()\nstring = \"s0\"\nprint(string)\nprint()\nprint(\"s0\")\nprint()\nboolean = True\nprint(boolean)\nprint()\nprint(True)\nprint()\ndict = {\"s1\": {\"s2\": 1}}\nprint(dict)\nprint()\nprint({\"s1\": {\"s2\": 1}})\nprint()\nset = {\"s1\", \"s2\", \"s3\"}\nprint(set)\nprint()\nprint({\"s1\", \"s2\", \"s3\"})\nprint()\ntuple = (\"s1\", \"s2\", \"s3\")\nprint(tuple)\nprint()\nprint((\"s1\", \"s2\", \"s3\"))\n</code></pre></p>"},{"location":"examples/fa-examples/#testing-functions","title":"Testing functions","text":"<p>The following <code>.theory</code> code snippet creates a DFA, NFA and DTM variable and does various function calls and printing. The DFA accepts all words that end with '00' or '11', and the NFA accepts any word that has the substring '101' or '11' in it. The DTM accepts any input string with the same amount of 0s and 1s.</p> <pre><code>dfa = DFA(\n{'s0', \"s1\", 's2', \"s3\", \"s4\"}, \n{\"0\", \"1\"}, \n{\"s0\": {\"0\": \"s3\", \"1\": \"s1\"}, \n\"s1\": {\"0\": \"s3\", \"1\": \"s2\"}, \n\"s2\": {\"0\": \"s3\", \"1\": \"s2\"}, \n\"s3\": {\"0\": \"s4\", \"1\": \"s1\"}, \n\"s4\": {\"0\": \"s4\", \"1\": \"s1\"}}, \n\"s0\", {\"s2\", \"s4\"}\n)\nprint(dfa)\nprint()\ndfa.save()\ndfa.save('dfa_wordcheck.png', '1011')\nprint(dfa.definition())\nprint()\nprint(dfa.test('1011'))\nprint()\nprint(open(\"dfa.png\"))\nnfa = NFA(\n{\"s0\", \"s1\", \"s2\", \"s3\"}, \n{\"0\", \"1\", \"\"}, \n{\"s0\": {\"0\": {\"s0\"}, \"1\": {\"s0\", \"s1\"}}, \n\"s1\": {\"0\": {\"s2\"}, \"\": {\"s2\"}}, \n\"s2\": {\"1\": {\"s3\"}}, \n\"s3\": {\"0\": {\"s3\"}, \"1\": {\"s3\"}}}, \n\"s0\", \n{\"s3\"}\n)\nprint(nfa)\nprint()\nnfa.save()\nnfa.save('nfa_wordcheck.png', '11')\nprint(nfa.definition())\nprint()\nprint(nfa.test('100101001'))\nprint()\nprint(open(\"nfa.png\"))\ndtm = DTM(\n{'q0', 'q1', 'q2', 'q3', 'q4'},\n{'0', '1'},\n{'0', '1', 'x', 'y', '#'},\n{\n'q0': {\n'0': ('q1', 'x', 'R'),\n'y': ('q3', 'y', 'R')\n},\n'q1': {\n'0': ('q1', '0', 'R'),\n'1': ('q2', 'y', 'L'),\n'y': ('q1', 'y', 'R')\n},\n'q2': {\n'0': ('q2', '0', 'L'),\n'x': ('q0', 'x', 'R'),\n'y': ('q2', 'y', 'L')\n},\n'q3': {\n'y': ('q3', 'y', 'R'),\n'#': ('q4', '#', 'R')\n}\n},\n'q0',\n'#',\n{'q4'}\n)\nprint(dtm)\nprint()\ndtm.save()\ndtm.save('dtm_wordcheck.png', '01')\nprint(dtm.definition())\nprint()\nprint(dtm.test('011'))\nprint()\nprint(open(\"dtm.png\"))\n</code></pre>"}]}